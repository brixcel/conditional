<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL Tree Visualization</title>
    <link rel="stylesheet" href="main.css">
</head>
<body>
    <h1>AVL Tree Visualization</h1>
    <p style="font-size: 1.2em; max-width: 800px; margin: 10px auto;">
        An <strong>AVL tree</strong> is a self-balancing binary search tree in which the difference between the heights of 
        the left and right subtrees of any node is at most one. This property ensures that the tree remains balanced, 
        providing efficient operations for insertion, deletion, and search, all of which have a time complexity of 
        <em>O(log n)</em>.
    </p>
    <input type="number" id="numberInput" placeholder="Enter a number">
    <button onclick="addNumber()">Add</button>
    <button onclick="rotateTreeLeft()">Rotate Left</button>
    <button onclick="rotateTreeRight()">Rotate Right</button>
    <button onclick="clearTree()">Clear</button>
    <button onclick="peekRoot()">Peek Root</button>
    <button onclick="peekParent()">Peek Parent</button>
    <button onclick="peekChildren()">Peek Children</button>
    <canvas id="avlTreeCanvas" style="border: 1px solid #000; margin-top: 20px;"></canvas>
    <p id="output" style="margin-top: 20px; font-size: 1.2em; color: #333;"></p>
    <div class="side-navbar" id="sideNavbar">
        <button class="close-btn" id="closeBtn">&times;</button>
        <a href="stack.html">Stack</a>
        <a href="regular-queue.html">Regular Queue</a>
        <a href="circular-queue.html">Circular Queue</a>
        <a href="priority-queue.html">Priority Queue</a>
        <a href="singly-linked-list.html">Singly Linked List</a>
        <a href="doubly-linked-list.html">Doubly Linked List</a>
        <a href="circular-linked-list.html">Circular Linked List</a>
        <a href="avl-tree.html">AVL Tree</a>
    </div>
    <script>
        class AVLNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.height = 1;
            }
        }

        class AVLTree {
            constructor() {
                this.root = null;
            }

            getHeight(node) {
                return node ? node.height : 0;
            }

            getBalanceFactor(node) {
                return node ? this.getHeight(node.left) - this.getHeight(node.right) : 0;
            }

            rotateRight(y) {
                const x = y.left;
                const T2 = x.right;

                x.right = y;
                y.left = T2;

                y.height = Math.max(this.getHeight(y.left), this.getHeight(y.right)) + 1;
                x.height = Math.max(this.getHeight(x.left), this.getHeight(x.right)) + 1;

                return x;
            }

            rotateLeft(x) {
                const y = x.right;
                const T2 = y.left;

                y.left = x;
                x.right = T2;

                x.height = Math.max(this.getHeight(x.left), this.getHeight(x.right)) + 1;
                y.height = Math.max(this.getHeight(y.left), this.getHeight(y.right)) + 1;

                return y;
            }

            insert(node, value) {
                if (!node) return new AVLNode(value);

                if (value < node.value) {
                    node.left = this.insert(node.left, value);
                } else if (value > node.value) {
                    node.right = this.insert(node.right, value);
                } else {
                    return node;
                }

                node.height = Math.max(this.getHeight(node.left), this.getHeight(node.right)) + 1;

                const balance = this.getBalanceFactor(node);

                if (balance > 1 && value < node.left.value) return this.rotateRight(node);
                if (balance < -1 && value > node.right.value) return this.rotateLeft(node);
                if (balance > 1 && value > node.left.value) {
                    node.left = this.rotateLeft(node.left);
                    return this.rotateRight(node);
                }
                if (balance < -1 && value < node.right.value) {
                    node.right = this.rotateRight(node.right);
                    return this.rotateLeft(node);
                }

                return node;
            }

            add(value) {
                this.root = this.insert(this.root, value);
                this.visualize();
            }

            rotateRootLeft() {
                if (this.root) {
                    this.root = this.rotateLeft(this.root);
                    this.visualize();
                }
            }

            rotateRootRight() {
                if (this.root) {
                    this.root = this.rotateRight(this.root);
                    this.visualize();
                }
            }

            clear() {
                this.root = null;
                this.visualize();
            }

            visualize() {
                const canvas = document.getElementById('avlTreeCanvas');
                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth * 0.8;
                canvas.height = 400;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (!this.root) return;

                const positions = new Map();

                const calculatePositions = (node, x, y, depth, minGap) => {
                    if (!node) return;

                    // Assign position for the current node
                    positions.set(node, { x, y });

                    // Calculate positions for child nodes
                    const gap = minGap / Math.pow(2, depth); // Reduce gap as depth increases
                    if (node.left) {
                        calculatePositions(node.left, x - gap, y + 70, depth + 1, minGap);
                    }
                    if (node.right) {
                        calculatePositions(node.right, x + gap, y + 70, depth + 1, minGap);
                    }
                };

                // Calculate positions starting from the root node
                calculatePositions(this.root, canvas.width / 2, 50, 0, canvas.width / 4);

                const drawNode = (node) => {
                    if (!node) return;

                    const { x, y } = positions.get(node);
                    const radius = 20;

                    // Draw edges to children
                    if (node.left) {
                        const leftPos = positions.get(node.left);
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(leftPos.x, leftPos.y);
                        ctx.stroke();
                    }
                    if (node.right) {
                        const rightPos = positions.get(node.right);
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(rightPos.x, rightPos.y);
                        ctx.stroke();
                    }

                    // Draw node
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = "#1877f2";
                    ctx.fill();
                    ctx.stroke();

                    // Draw value
                    ctx.fillStyle = "white";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(node.value, x, y);

                    // Recursively draw children
                    drawNode(node.left);
                    drawNode(node.right);
                };

                // Start drawing from the root node
                drawNode(this.root);
            }

            peekRoot() {
                return this.root ? `Root Node: ${this.root.value}` : 'Tree is empty.';
            }

            peekParent(value, node = this.root, parent = null) {
                if (!node) return `Node with value ${value} not found.`;
                if (node.value === value) return parent ? `Parent Node: ${parent.value}` : 'This node is the root and has no parent.';
                return value < node.value
                    ? this.peekParent(value, node.left, node)
                    : this.peekParent(value, node.right, node);
            }

            peekChildren(value, node = this.root) {
                if (!node) return `Node with value ${value} not found.`;
                if (node.value === value) {
                    const leftChild = node.left ? node.left.value : 'None';
                    const rightChild = node.right ? node.right.value : 'None';
                    return `Children of Node ${value}: Left = ${leftChild}, Right = ${rightChild}`;
                }
                return value < node.value
                    ? this.peekChildren(value, node.left)
                    : this.peekChildren(value, node.right);
            }
        }

        // Initialize AVL Tree
        const avlTree = new AVLTree();

        // Add number to the tree
        function addNumber() {
            const numberInput = document.getElementById('numberInput');
            const value = parseInt(numberInput.value, 10);

            if (!isNaN(value)) {
                avlTree.add(value);
                numberInput.value = '';
            } else {
                alert('Please enter a valid number.');
            }
        }

        // Rotate tree left at root
        function rotateTreeLeft() {
            avlTree.rotateRootLeft();
        }

        // Rotate tree right at root
        function rotateTreeRight() {
            avlTree.rotateRootRight();
        }

        // Clear the tree
        function clearTree() {
            avlTree.clear();
        }

        // Peek functions
        function peekRoot() {
            const output = avlTree.peekRoot();
            document.getElementById('output').innerText = output;
        }

        function peekParent() {
            const value = parseInt(prompt('Enter the node value to find its parent:'), 10);
            if (!isNaN(value)) {
                const output = avlTree.peekParent(value);
                document.getElementById('output').innerText = output;
            } else {
                alert('Please enter a valid number.');
            }
        }

        function peekChildren() {
            const value = parseInt(prompt('Enter the node value to find its children:'), 10);
            if (!isNaN(value)) {
                const output = avlTree.peekChildren(value);
                document.getElementById('output').innerText = output;
            } else {
                alert('Please enter a valid number.');
            }
        }
    </script>
</body>
</html>


