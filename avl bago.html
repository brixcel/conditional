<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL Tree Visualization</title>
    <link rel="stylesheet" href="avl.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        h1 {
            color: #333;
        }
        .check {
            margin-bottom: 20px;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
        }
        .check h2 {
            margin: 0;
            color: #007BFF;
        }
        .check p {
            margin: 5px 0;
        }
        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* Body and Overall Layout */
body {
    font-family: 'Arial', sans-serif;
    background-color: #f4f4f9;
    color: #333;
    line-height: 1.6;
    padding: 20px;
}

/* Header */
h1 {
    text-align: center;
    font-size: 2.5em;
    margin-bottom: 20px;
}

/* Paragraph Styling */
p {
    font-size: 1.2em;
    max-width: 900px;
    margin: 20px auto;
    text-align: justify;
    line-height: 1.5;
}

/* Input & Button Section */
input[type="number"] {
    font-size: 1.1em;
    padding: 10px;
    margin-right: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    width: 150px;
}

button {
    font-size: 1.1em;
    padding: 10px 15px;
    margin: 10px 5px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background-color: #1877f2;
    color: white;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

button:hover {
    background-color: #155c8a;
}

/* Align Buttons Horizontally */
#button-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    margin-top: 20px;
}

button {
    margin: 10px;
}

button:focus {
    outline: none;
}

/* Canvas Styling */
#avlTreeCanvas {
    display: block;
    margin: 30px auto;
    background-color: #fff;
    border: 2px solid #ddd;
    max-width: 100%;
    height: auto;
}

/* Output Section */
#output {
    font-size: 1.2em;
    color: #333;
    margin-top: 20px;
    text-align: center;
    padding: 15px;
    background-color: #fff;
    border-radius: 5px;
    border: 1px solid #ccc;
    max-width: 900px;
    margin: 30px auto;
}

/* Flexbox for large screen devices */
@media (min-width: 768px) {
    body {
        max-width: 1200px;
        margin: 0 auto;
    }

    #button-container {
        justify-content: space-between;
    }
}

@media (max-width: 767px) {
    h1 {
        font-size: 2em;
    }

    input[type="number"], button {
        font-size: 1em;
    }

    #button-container {
        flex-direction: column;
        align-items: center;
    }

    #output {
        font-size: 1em;
    }
}
    </style>
</head>
<body>
    <h1>AVL Tree Visualization</h1>
    <p style="font-size: 1.2em; max-width: 800px; margin: 10px auto;">
        An <strong>AVL tree</strong> is a self-balancing binary search tree in which the difference between the heights of 
        the left and right subtrees of any node is at most one. This property ensures that the tree remains balanced, 
        providing efficient operations for insertion, deletion, and search, all of which have a time complexity of 
        <em>O(log n)</em>.
    </p>

    <input type="number" id="numberInput" placeholder="Enter a number">
    <button onclick="EnqueueNumber()">Enqueue</button>
    <button onclick="clearTree()">Delete all</button>
    <button onclick="peekRoot()">Root</button>
    <button onclick="peekParent()">Parent</button>
    <button onclick="peekChildren()">Child/Children</button>
    <button onclick="showSubtrees()">Subtrees</button>
    <button onclick="showLeafNodes()">LeafNodes</button>
    <button onclick="showSiblings()">Siblings</button>
    <button onclick="updateNode()">Update</button>
    <button onclick="deleteNode()">Delete</button>
    <button onclick="showTreeHeight()">Level</button>
    <button onclick="balanceTree()">Balance</button>


    <canvas id="avlTreeCanvas" style="border: 1px solid #000; margin-top: 20px;"></canvas>
    <p id="output" style="margin-top: 20px; font-size: 1.2em; color: #333;"></p>
    
    <h2>check Descriptions</h2>
    <div class="check">
        <h2>Enqueue</h2>
        <p>Inserts a new value into the AVL tree while maintaining its balance. It updates the tree structure and visualizes the changes.</p>
    </div>

    <div class="check">
        <h2>clear()</h2>
        <p>Removes all nodes from the AVL tree, effectively resetting it to an empty state. This check also updates the visualization to reflect the cleared tree.</p>
    </div>

    <div class="check">
        <h2>Root()</h2>
        <p>Retrieves and displays the value of the root node of the AVL tree. If the tree is empty, it informs the user that there is no root node.</p>
    </div>

    <div class="check">
        <h2>Parent(value)</h2>
        <p>Finds and displays the parent node of a specified value in the tree. If the value is the root or not found, it provides appropriate feedback.</p>
    </div>

    <div class="check">
        <h2>Children(value)</h2>
        <p>Displays the left and right children of a specified node value. If the node has no children, it indicates that as well.</p>
    </div>

    <div class="check">
        <h2>Subtrees()</h2>
        <p>Lists all subtrees in the AVL tree, showing the nodes under each parent node. This helps users understand the structure of the tree.</p>
    </div>

    <div class="check">
        <h2>LeafNodes()</h2>
        <p>Identifies and displays all leaf nodes in the tree, which are nodes without any children.</p>
    </div>

    <div class="check">
        <h2>Siblings()</h2>
        <p>Displays pairs of sibling nodes in the tree. This check helps users visualize relationships between nodes.</ </div>

    <div class="check">
        <h2>Update()</h2>
        <p>Allows the user to update the value of a specified node. It first removes the old value and then Enqueues the new value, ensuring the tree remains balanced.</p>
    </div>

    <div class="check">
        <h2>Delete()</h2>
        <p>Removes a specified node from the AVL tree. It updates the tree structure and visualizes the changes, ensuring the tree remains balanced after deletion.</p>
    </div>

    <div class="check">
        <h2>Level()</h2>
        <p>Calculates and displays the height of the AVL tree, which indicates the number of levels in the tree.</p>
    </div>

    <div class="check">
        <h2>Balance()</h2>
        <p>Rebalances the AVL tree by clearing it and rebuilding it from the sorted list of its nodes. This ensures optimal performance for future operations.</p>
    </div>

    <script>
        class AvlClassTreeeeeNodes {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.height = 1;
            }
        }

        class AvlClassTreeee {
            constructor() {
                this.root = null;
            }

            getHeight(node) {
                return node ? node.height : 0;
            }

            getTreeHeight() {
                const getHeightRecursive = (node) => {
                    if (!node) return 0; // No node means no height
                    return Math.max(getHeightRecursive(node.left), getHeightRecursive(node.right)) + 1;
                };

            return getHeightRecursive(this.root);
            }

            getBalanceFactor(node) {
                return node ? this.getHeight(node.left) - this.getHeight(node.right) : 0;
            }

            rotateRight(y) {
                const x = y.left;
                const T2 = x.right;

                x.right = y;
                y.left = T2;

                y.height = Math.max(this.getHeight(y.left), this.getHeight(y.right)) + 1;
                x.height = Math.max(this.getHeight(x.left), this.getHeight(x.right)) + 1;

                return x;
            }

            rotateLeft(x) {
                const y = x.right;
                const T2 = y.left;

                y.left = x;
                x.right = T2;

                x.height = Math.max(this.getHeight(x.left), this.getHeight(x.right)) + 1;
                y.height = Math.max(this.getHeight(y.left), this.getHeight(y.right)) + 1;

                return y;
            }

            insert(node, value) {
                if (!node) return new AvlClassTreeeeeNodes(value);

                if (value < node.value) {
                    node.left = this.insert(node.left, value);
                } else if (value > node.value) {
                    node.right = this.insert(node.right, value);
                } else {
                    return node;
                }

                node.height = Math.max(this.getHeight(node.left), this.getHeight(node.right)) + 1;

                const balance = this.getBalanceFactor(node);

                if (balance > 1 && value < node.left.value) return this.rotateRight(node);
                if (balance < -1 && value > node.right.value) return this.rotateLeft(node);
                if (balance > 1 && value > node.left.value) {
                    node.left = this.rotateLeft(node.left);
                    return this.rotateRight(node);
                }
                if (balance < -1 && value < node.right.value) {
                    node.right = this.rotateRight(node.right);
                    return this.rotateLeft(node);
                }

                return node;
            }

            Enqueue(value) {
                this.root = this.insert(this.root, value);
                this.visualize();
            }

            rotateRootLeft() {
                if (this.root) {
                    this.root = this.rotateLeft(this.root);
                    this.visualize();
                }
            }

            rotateRootRight() {
                if (this.root) {
                    this.root = this.rotateRight(this.root);
                    this.visualize();
                }
            }

            clear() {
                this.root = null;
                this.visualize();
            }

            visualize() {
                const canvas = document.getElementById('avlTreeCanvas');
                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth * 0.8;
                canvas.height = 400;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (!this.root) return;

                const positions = new Map();

                const calculatePositions = (node, x, y, depth, minGap) => {
                    if (!node) return;

                    // Assign position for the current node
                    positions.set(node, { x, y });

                    // Calculate positions for child nodes
                    const gap = minGap / Math.pow(2, depth); // Reduce gap as depth increases
                    if (node.left) {
                        calculatePositions(node.left, x - gap, y + 70, depth + 1, minGap);
                    }
                    if (node.right) {
                        calculatePositions(node.right, x + gap, y + 70, depth + 1, minGap);
                    }
                };

                // Calculate positions starting from the root node
                calculatePositions(this.root, canvas.width / 2, 50, 0, canvas.width / 4);

                const drawNode = (node) => {
                    if (!node) return;

                    const { x, y } = positions.get(node);
                    const radius = 20;

                    // Draw edges to children
                    if (node.left) {
                        const leftPos = positions.get(node.left);
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(leftPos.x, leftPos.y);
                        ctx.stroke();
                    }
                    if (node.right) {
                        const rightPos = positions.get(node.right);
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(rightPos.x, rightPos.y);
                        ctx.stroke();
                    }

                    // Draw node
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = "#1877f2";
                    ctx.fill();
                    ctx.stroke();

                    // Draw value
                    ctx.fillStyle = "white";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(node.value, x, y);

                    // Recursively draw children
                    drawNode(node.left);
                    drawNode(node.right);
                };

                // Start drawing from the root node
                drawNode(this.root);
            }

            peekRoot() {
                return this.root ? `Root Node: ${this.root.value}` : 'Tree is empty.';
            }

            peekParent(value, node = this.root, parent = null) {
                if (!node) return `Node with value ${value} not found.`;
                if (node.value === value) return parent ? `Parent Node: ${parent.value}` : 'This node is the root and has no parent.';
                return value < node.value
                    ? this.peekParent(value, node.left, node)
                    : this.peekParent(value, node.right, node);
            }

            peekChildren(value, node = this.root) {
                if (!node) return `Node with value ${value} not found.`;
                if (node.value === value) {
                    const leftChild = node.left ? node.left.value : 'None';
                    const rightChild = node.right ? node.right.value : 'None';
                    return `Children of Node ${value}: Left = ${leftChild}, Right = ${rightChild}`;
                }
                return value < node.value
                    ? this.peekChildren(value, node.left)
                    : this.peekChildren(value, node.right);
            }
        }

        // Initialize AVL Tree
        const AvlClassTree= new AVLTree();

        function EnqueueNumber() {
        const numberInput = document.getElementById('numberInput');
        const value = parseInt(numberInput.value, 10);

        // Validate if the input is a positive number
        if (isNaN(value) || value <= 0) {
            alert('Please enter a valid positive number.');
            return;
        }

    // Enqueue the number to the AVL tree
    avlTree.Enqueue(value);
    numberInput.value = '';  // Clear the input field after Enqueueing
}


        // Rotate tree left at root
        function rotateTreeLeft() {
            avlTree.rotateRootLeft();
        }

        // Rotate tree right at root
        function rotateTreeRight() {
            avlTree.rotateRootRight();
        }

        // Clear the tree
        function clearTree() {
            avlTree.clear();
        }

        // Peek functions
        function peekRoot() {
            const output = avlTree.peekRoot();
            document.getElementById('output').innerText = output;
        }

        function peekParent() {
            const value = parseInt(prompt('Enter the node value to find its parent:'), 10);
            if (!isNaN(value)) {
                const output = avlTree.peekParent(value);
                document.getElementById('output').innerText = output;
            } else {
                alert('Please enter a valid number.');
            }
        }

        function peekChildren() {
            const value = parseInt(prompt('Enter the node value to find its children:'), 10);
            if (!isNaN(value)) {
                const output = avlTree.peekChildren(value);
                document.getElementById('output').innerText = output;
            } else {
                alert('Please enter a valid number.');
            }
        }

        // Function to display subtrees (all nodes under each node in the tree)
        function showSubtrees() {
            const subtrees = getSubtrees(avlTree.root);
            const output = subtrees.length ? `Subtrees: ${subtrees.map(subtree => `(${subtree.join(', ')})`).join(', ')}` : 'No subtrees found.';
            document.getElementById('output').innerText = output;
        }

// Helper function to get subtrees starting from a given node
        function getSubtrees(node) {
        if (!node) return [];
        let subtrees = [];

        const collectSubtree = (n) => {
            if (!n) return [];
            let nodes = [n.value];
            nodes = nodes.concat(collectSubtree(n.left));
            nodes = nodes.concat(collectSubtree(n.right));
            return nodes;
        };

        if (node) {
            subtrees.push(collectSubtree(node));
            subtrees = subtrees.concat(getSubtrees(node.left));
            subtrees = subtrees.concat(getSubtrees(node.right));
        }

        return subtrees;
    }

    

// Function to display leaf nodes (nodes without children)
    function showLeafNodes() {
        const leafNodes = getLeafNodes(avlTree.root);
        const output = leafNodes.length ? `Leaf Nodes: ${leafNodes.join(', ')}` : 'No leaf nodes found.';
        document.getElementById('output').innerText = output;
    }

// Helper function to get leaf nodes (nodes with no children)
    function getLeafNodes(node) {
        let leaves = [];
        if (!node) return leaves;

        if (!node.left && !node.right) {
            leaves.push(node.value);
        } else {
            leaves = leaves.concat(getLeafNodes(node.left));
            leaves = leaves.concat(getLeafNodes(node.right));
        }
        return leaves;
    }

    function showSiblings() {
    const siblingPairs = getAllSiblingPairs(avlTree.root);
    const output = siblingPairs.length
        ? `Sibling Pairs: ${siblingPairs.map(pair => `(${pair.join(', ')})`).join(', ')}`
        : 'No sibling pairs found.';
    document.getElementById('output').innerText = output;
}

// Function to gather all sibling pairs
function getAllSiblingPairs(node, parent = null) {
    if (!node) return [];

    let siblingPairs = [];

    // If there's a parent, check if this node has siblings
    if (parent) {
        // Check if the parent has left and right children
        if (parent.left && parent.right) {
            // Form a pair and Enqueue to sibling pairs
            siblingPairs.push([parent.left.value, parent.right.value]);
        }
    }

    // Recursively check left and right children
    siblingPairs = siblingPairs.concat(getAllSiblingPairs(node.left, node));
    siblingPairs = siblingPairs.concat(getAllSiblingPairs(node.right, node));

    return siblingPairs;
}


    function updateNode() {
    const oldValue = parseInt(prompt('Enter the current value of the node to update:'), 10);
    const newValue = parseInt(prompt('Enter the new value for the node:'), 10);

    if (!isNaN(oldValue) && !isNaN(newValue)) {
        const nodeToUpdate = findNode(avlTree.root, oldValue);

        if (nodeToUpdate) {
            // Remove the old value by deleting the node and Enqueueing the new value
            avlTree.root = removeNode(avlTree.root, oldValue);
            avlTree.Enqueue(newValue);

            // Output the updated tree
            document.getElementById('output').innerText = `Node updated from ${oldValue} to ${newValue}.`;
        } else {
            alert(`Node with value ${oldValue} not found.`);
        }
    } else {
        alert('Please enter valid numbers.');
    }
}

// Helper function to find a node by value
function findNode(node, value) {
    if (!node) return null;
    if (node.value === value) return node;
    if (value < node.value) return findNode(node.left, value);
    return findNode(node.right, value);
}

// Helper function to remove a node by value
function removeNode(node, value) {
    if (!node) return node;

    // Perform standard BST deletion
    if (value < node.value) {
        node.left = removeNode(node.left, value);
    } else if (value > node.value) {
        node.right = removeNode(node.right, value);
    } else {
        // Node to be deleted found
        if (!node.left) {
            return node.right;
        } else if (!node.right) {
            return node.left;
        }

        // Node with two children, get the inorder successor
        node.value = minValue(node.right);
        node.right = removeNode(node.right, node.value);
    }

    node.height = Math.max(avlTree.getHeight(node.left), avlTree.getHeight(node.right)) + 1;

    // Rebalance the tree if necessary
    const balance = avlTree.getBalanceFactor(node);
    if (balance > 1 && avlTree.getBalanceFactor(node.left) >= 0) {
        return avlTree.rotateRight(node);
    }
    if (balance < -1 && avlTree.getBalanceFactor(node.right) <= 0) {
        return avlTree.rotateLeft(node);
    }
    if (balance > 1 && avlTree.getBalanceFactor(node.left) < 0) {
        node.left = avlTree.rotateLeft(node.left);
        return avlTree.rotateRight(node);
    }
    if (balance < -1 && avlTree.getBalanceFactor(node.right) > 0) {
        node.right = avlTree.rotateRight(node.right);
        return avlTree.rotateLeft(node);
    }

    return node;
}

// Helper function to find the minimum value node
function minValue(node) {
    let current = node;
    while (current.left) {
        current = current.left;
    }
    return current.value;
}

// Function to delete a specific node
function deleteNode() {
    const valueToDelete = parseInt(prompt('Enter the value of the node to delete:'), 10);

    if (!isNaN(valueToDelete)) {
        const nodeToDelete = findNode(avlTree.root, valueToDelete);

        if (nodeToDelete) {
            // Remove the node
            avlTree.root = removeNode(avlTree.root, valueToDelete);

            // Output the updated tree
            document.getElementById('output').innerText = `Node with value ${valueToDelete} deleted.`;
        } else {
            alert(`Node with value ${valueToDelete} not found.`);
        }
    } else {
        alert('Please enter a valid number.');
    }
}

// Helper function to find a node by value
function findNode(node, value) {
    if (!node) return null;
    if (node.value === value) return node;
    if (value < node.value) return findNode(node.left, value);
    return findNode(node.right, value);
}

// Helper function to remove a node from the tree
function removeNode(node, value) {
    if (!node) return node;

    // Step 1: Perform standard BST deletion
    if (value < node.value) {
        node.left = removeNode(node.left, value);
    } else if (value > node.value) {
        node.right = removeNode(node.right, value);
    } else {
        // Node with the value found
        // Case 1: Node has no child (leaf node)
        if (!node.left && !node.right) {
            return null;
        }
        // Case 2: Node has one child
        if (!node.left) {
            return node.right;
        } else if (!node.right) {
            return node.left;
        }

        // Case 3: Node has two children
        // Get the inorder successor (smallest in the right subtree)
        node.value = minValue(node.right);
        // Delete the inorder successor
        node.right = removeNode(node.right, node.value);
    }

    // Step 2: Update height and rebalance if needed
    node.height = Math.max(avlTree.getHeight(node.left), avlTree.getHeight(node.right)) + 1;

    // Rebalance the tree if necessary
    const balance = avlTree.getBalanceFactor(node);

    if (balance > 1 && avlTree.getBalanceFactor(node.left) >= 0) {
        return avlTree.rotateRight(node);
    }
    if (balance < -1 && avlTree.getBalanceFactor(node.right) <= 0) {
        return avlTree.rotateLeft(node);
    }
    if (balance > 1 && avlTree.getBalanceFactor(node.left) < 0) {
        node.left = avlTree.rotateLeft(node.left);
        return avlTree.rotateRight(node);
    }
    if (balance < -1 && avlTree.getBalanceFactor(node.right) > 0) {
        node.right = avlTree.rotateRight(node.right);
        return avlTree.rotateLeft(node);
    }

    return node;
}

// Function to delete a specific node
function deleteNode() {
    const valueToDelete = parseInt(prompt('Enter the value of the node to delete:'), 10);

    if (!isNaN(valueToDelete)) {
        const nodeToDelete = findNode(avlTree.root, valueToDelete);

        if (nodeToDelete) {
            // Remove the node
            avlTree.root = removeNode(avlTree.root, valueToDelete);

            // Output the updated tree
            document.getElementById('output').innerText = `Node with value ${valueToDelete} deleted.`;

            // Re-render the tree visualization
            avlTree.visualize();
        } else {
            alert(`Node with value ${valueToDelete} not found.`);
        }
    } else {
        alert('Please enter a valid number.');
    }
}


// Helper function to find the minimum value node
function minValue(node) {
    let current = node;
    while (current.left) {
        current = current.left;
    }
    return current.value;
}

    function showTreeHeight() {
        const height = avlTree.getTreeHeight();
        document.getElementById('output').innerText = `Tree Height (Number of Levels): ${height}`;
    }

    function balanceTree() {
    // First, get all the nodes in the tree in sorted order
    const nodes = getSortedNodes(avlTree.root);
    
    // Clear the tree
    avlTree.clear();

    // Rebuild the tree from the sorted node list to ensure it's balanced
    avlTree.root = buildBalancedTree(nodes); // Assign the new root to the AVL tree

    // Re-render the tree visualization
    avlTree.visualize();
    
    document.getElementById('output').innerText = 'Tree has been rebalanced.';
}

// Helper function to traverse the tree in-order and return all nodes
function getSortedNodes(node) {
    if (!node) return [];
    const leftNodes = getSortedNodes(node.left);
    const rightNodes = getSortedNodes(node.right);
    return [...leftNodes, node.value, ...rightNodes];
}

// Helper function to build a balanced tree from a sorted array of values
function buildBalancedTree(values) {
    if (values.length === 0) return null;
    
    // Find the middle value (root of the subtree)
    const mid = Math.floor(values.length / 2);
    const root = new AvlClassTreeeeeNodes(values[mid]);

    // Recursively build the left and right subtrees
    root.left = buildBalancedTree(values.slice(0, mid));  // Left half
    root.right = buildBalancedTree(values.slice(mid + 1)); // Right half

    // Recalculate height and balance factor for the root node
    root.height = Math.max(avlTree.getHeight(root.left), avlTree.getHeight(root.right)) + 1;
    
    return root;
}


// Helper function to build a balanced tree from a sorted array of values
function buildBalancedTree(values) {
    if (values.length === 0) return null;
    
    // Find the middle value (root of the subtree)
    const mid = Math.floor(values.length / 2);
    const root = new AvlClassTreeeeeNodes(values[mid]);

    // Recursively build the left and right subtrees
    root.left = buildBalancedTree(values.slice(0, mid));  // Left half
    root.right = buildBalancedTree(values.slice(mid + 1)); // Right half

    // Recalculate height and balance factor for the root node
    root.height = Math.max(avlTree.getHeight(root.left), avlTree.getHeight(root.right)) + 1;
    
    return root;
}

    
    </script>
</body>
</html>
